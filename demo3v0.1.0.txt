// demo3.cpp : 定义控制台应用程序的入口点。
//双线程播放笔记本摄像头，线程一调用摄像头读取帧到Mat队列，线程二从Mat队列读取帧显示播放

#include "stdafx.h"
#include "Windows.h"
#include <thread>
#include <mutex>
#include <condition_variable>
#include <iostream>
#include <list>
#include <opencv2/opencv.hpp>
#include <opencv2/tracking.hpp>
#include <opencv2/core/ocl.hpp>



using namespace std;
using namespace cv;


#define MAX_SIZE 70
#define TOTAL 500
//CRITICAL_SECTION g_cs_frameList;
std::list<Mat> g_frameList;
list<int> testList;
int i = -1;
mutex mu;
condition_variable cond;

void readFrame() 
{
	Mat temp_frame;

	VideoCapture cap(0);
	if (!cap.isOpened())
		return ;
	
	while (1) 
	{
		cap >> temp_frame;
		if (temp_frame.empty())
		{
			break;
		}
		std::unique_lock<std::mutex> locker(mu);//lock
		if (MAX_SIZE == g_frameList.size())
			g_frameList.pop_front();
		g_frameList.push_back(temp_frame);
		++i;
		if (i > TOTAL)
		{
			g_frameList.clear();
			locker.unlock();//unlock
			break;
		}
			
		//locker.unlock();//unlock
		cond.notify_one();
	}

	cap.release();
	return;
}

void track()
{
	Mat temp_frame;
	while (1)
	{
		std::unique_lock<std::mutex> locker(mu);//lock
		while (g_frameList.empty())
		{	 
			cond.wait(locker);
		}
		if (i > TOTAL - 1)//确定结束条件，处理帧停止后还需收集帧，否则无法唤醒处理程序
		{
			locker.unlock();//unlock
			destroyAllWindows();
			return;
		}
		temp_frame = *g_frameList.begin();
		cout << g_frameList.size() << endl;
		g_frameList.pop_front();
		locker.unlock();//unlock
		imshow("temp" , temp_frame);
		waitKey(1);
	}
	//destroyAllWindows();
	return;
}

int main()
{
	thread reader(readFrame);
	//Sleep(1);
	thread tracker(track);
	
		
	reader.join();
	tracker.join();
	
	//cout << g_frameList.max_size() <<endl;
	//cout << testList.max_size() << endl;
	system("pause");
    return 0;
}

